{"ast":null,"code":"import { Map } from \"immutable\";\nimport { talentsBySpec, talentToSpec, talentsBySpecArray, talentsById } from \"../data/talents\";\nimport { classById } from \"../data/classes\";\nimport spells from \"../data/spells.json\";\nexport const MAX_POINTS = 51;\nexport const MAX_ROWS = 7;\nexport const SORT_TALENTS = (a, b) => {\n  if (a.row === b.row) {\n    return a.col - b.col;\n  }\n  return a.row - b.row;\n};\n_c = SORT_TALENTS;\nexport const SORT_TALENTS_DESC = (a, b) => {\n  if (a.row === b.row) {\n    return b.col - a.col;\n  }\n  return b.row - a.row;\n};\n_c2 = SORT_TALENTS_DESC;\nexport const SORT_TALENTS_BY_SPEC = (a, b) => {\n  const aSpec = talentToSpec[a.id];\n  const bSpec = talentToSpec[b.id];\n  if (aSpec === bSpec) {\n    return SORT_TALENTS(a, b);\n  }\n  return aSpec - bSpec;\n};\n\n/**\n * Returns the overall points spent in the tree.\n */\n_c3 = SORT_TALENTS_BY_SPEC;\nexport function getPointsInSpec(specId, known) {\n  // TODO: Hard to test this method when referencing talents from a file. Improve this.\n  return Object.values(talentsBySpec[specId]).reduce((prev, current) => {\n    return prev + known.get(current.id, 0);\n  }, 0);\n}\nexport function calcAvailablePoints(known) {\n  return Math.max(0, MAX_POINTS - known.reduce((prev, current) => prev + current, 0));\n}\n\n/**\n * Returns whether a talent's other talent requirements are met.\n */\nexport function calcMeetsRequirements(talent, known) {\n  if (talent.requires.length === 0) {\n    return true;\n  }\n  return talent.requires.reduce((prev, req) => {\n    if (!prev) return false;\n    return known.get(req.id, 0) >= req.qty;\n  }, true);\n}\nexport function getNameForTalent(talentId) {\n  const spell = spells[talentsById[talentId].ranks[0]];\n  if (spell) return spell.name;\n  return \"Unknown\";\n}\nexport function getUnmetRequirements(talent, known, pointsInSpec, specName) {\n  const missing = [];\n  const dependency = talent.requires[0];\n  if (dependency && known.get(dependency.id, 0) < dependency.qty) {\n    missing.push(`Requires ${dependency.qty} point${dependency.qty !== 1 ? \"s\" : \"\"} in ${getNameForTalent(dependency.id)}`);\n  }\n  if (talent.row * 5 > pointsInSpec) {\n    missing.push(`Requires ${talent.row * 5} points in ${specName}`);\n  }\n\n  // Hackfix: Returning an Array will cause the prop to change everytime, causing re-renders on all\n  // of the components. Returning a string makes the shallow compare easier and prevents re-renders.\n  // Could add Memoization to this function, but not sure of another \"better\" more \"React\" way..\n  return missing.join(\"_\");\n}\nexport const canLearnTalent = (known, talent) => {\n  // Reached the max rank?\n  if (known.get(talent.id, 0) >= talent.ranks.length) {\n    return false;\n  }\n\n  // Spend a maximum of 51 points\n  if (calcAvailablePoints(known) === 0) {\n    return false;\n  }\n\n  // Support for specific Talent dependency requirement.\n  if (talent.requires.length > 0 && !calcMeetsRequirements(talent, known)) {\n    return false;\n  }\n\n  // Check we have the required amount of points spent in the tree for this talent\n  const requiredPoints = talent.row * 5;\n  const pointsInSpec = getPointsInSpec(talentToSpec[talent.id], known);\n  if (requiredPoints > pointsInSpec) {\n    return false;\n  }\n  return true;\n};\nexport const getCumulativePointsPerRow = (known, specId) => {\n  return known.reduce((reduction, points, talentId) => {\n    const t = talentsBySpec[specId][talentId];\n    if (t && points > 0) {\n      for (let row = t.row; row < MAX_ROWS; row++) {\n        reduction[row] = (reduction[row] || 0) + points;\n      }\n    }\n    return reduction;\n  }, []);\n};\nexport const canUnlearnTalent = (known, talent) => {\n  const currentPoints = known.get(talent.id, 0);\n  const specId = talentToSpec[talent.id];\n\n  // No points to reduce for this talent\n  if (currentPoints === 0) {\n    console.warn(\"no points to reduce\");\n    return false;\n  }\n\n  // Prevent if another talent depends on this\n  const isDependency = known.some((points, talentId) => {\n    const t = talentsBySpec[specId][talentId];\n    return t && points > 0 && t.requires.some(req => req.id === talent.id);\n  });\n  if (isDependency) {\n    console.warn(\"is dependency\");\n    return false;\n  }\n\n  // Walk through every talent and ensure no requirements are breached\n  let cumulativePointsPerRow = getCumulativePointsPerRow(known, specId);\n  for (let r = talent.row; r < cumulativePointsPerRow.length; r++) {\n    // Calculate what the points would look like when this one is removed\n    cumulativePointsPerRow[r] = cumulativePointsPerRow[r] - 1;\n  }\n  const wouldBreach = known.some((points, talentId) => {\n    const t = talentsBySpec[specId][talentId];\n    return t && points > 0 && t.row > 0 && cumulativePointsPerRow[t.row - 1] < t.row * 5;\n  });\n  if (wouldBreach) {\n    console.warn(\"point requirements would be breached\");\n    return false;\n  }\n  return true;\n};\n\n/**\n * Adds a single talent point to the Map, if possible.\n */\nexport const addTalentPoint = (known, talent) => {\n  const currentPoints = known.get(talent.id, 0);\n  if (!canLearnTalent(known, talent)) {\n    return known;\n  }\n  return known.set(talent.id, currentPoints + 1);\n};\n\n/**\n * Removes a single talent point from the Map, if possible.\n */\nexport const removeTalentPoint = (known, talent) => {\n  const currentPoints = known.get(talent.id, 0);\n  if (!canUnlearnTalent(known, talent)) {\n    return known;\n  }\n  return currentPoints === 1 ? known.remove(talent.id) : known.set(talent.id, currentPoints - 1);\n};\n\n/**\n * Either adds or removes a talent point based on the modifier.\n */\nexport const modifyTalentPoint = (known, talent, modifier) => {\n  if (modifier === 1) {\n    return addTalentPoint(known, talent);\n  } else {\n    return removeTalentPoint(known, talent);\n  }\n};\n\n/**\n * Encodes a Map of known talents into a URL-friendly string.\n */\nexport function encodeKnownTalents(known, classId) {\n  let string = \"\";\n  const {\n    specs\n  } = classById[classId];\n  for (let i = 0; i < specs.length; i++) {\n    const specId = specs[i];\n    const talents = talentsBySpecArray[specId].sort(SORT_TALENTS);\n    string += i > 0 ? \"-\" : \"\";\n    string += removeTrailingCharacters(talents.map(talent => known.get(talent.id, 0)).join(\"\"), \"0\");\n  }\n  return removeTrailingCharacters(string, \"-\");\n}\n\n/**\n * Decodes a string of points into a Map of talents.\n */\nexport function decodeKnownTalents(pointString, classId) {\n  const {\n    specs\n  } = classById[classId];\n  let known = Map();\n\n  // TODO: Make sure we validate the point string\n  const parts = pointString.split(\"-\");\n  for (let i = 0; i < parts.length; i++) {\n    const specId = specs[i];\n    const specPointStr = parts[i];\n    const talents = talentsBySpecArray[specId].sort(SORT_TALENTS);\n    for (let y = 0; y < specPointStr.length; y++) {\n      const talent = talents[y];\n      const points = parseInt(specPointStr[y], 10);\n\n      // Validation: break out loop if there's more points in the string than this talent can have\n      if (points > talent.ranks.length) {\n        break;\n      }\n\n      // Step through each point and see that we can assign it\n      for (let p = 0; p < points; p++) {\n        if (canLearnTalent(known, talent)) {\n          known = known.set(talent.id, p + 1);\n        } else {\n          break;\n        }\n      }\n    }\n  }\n  return known;\n}\n\n/**\n * Removes repeated characters from the end of a string.\n */\nfunction removeTrailingCharacters(str, char) {\n  while (str[str.length - 1] === char) {\n    str = str.slice(0, -1);\n  }\n  return str;\n}\nvar _c, _c2, _c3;\n$RefreshReg$(_c, \"SORT_TALENTS\");\n$RefreshReg$(_c2, \"SORT_TALENTS_DESC\");\n$RefreshReg$(_c3, \"SORT_TALENTS_BY_SPEC\");","map":{"version":3,"names":["Map","talentsBySpec","talentToSpec","talentsBySpecArray","talentsById","classById","spells","MAX_POINTS","MAX_ROWS","SORT_TALENTS","a","b","row","col","_c","SORT_TALENTS_DESC","_c2","SORT_TALENTS_BY_SPEC","aSpec","id","bSpec","_c3","getPointsInSpec","specId","known","Object","values","reduce","prev","current","get","calcAvailablePoints","Math","max","calcMeetsRequirements","talent","requires","length","req","qty","getNameForTalent","talentId","spell","ranks","name","getUnmetRequirements","pointsInSpec","specName","missing","dependency","push","join","canLearnTalent","requiredPoints","getCumulativePointsPerRow","reduction","points","t","canUnlearnTalent","currentPoints","console","warn","isDependency","some","cumulativePointsPerRow","r","wouldBreach","addTalentPoint","set","removeTalentPoint","remove","modifyTalentPoint","modifier","encodeKnownTalents","classId","string","specs","i","talents","sort","removeTrailingCharacters","map","decodeKnownTalents","pointString","parts","split","specPointStr","y","parseInt","p","str","char","slice","$RefreshReg$"],"sources":["E:/1/curswork/curswork - JSJSJSJSJS/src/lib/tree.js"],"sourcesContent":["import { Map } from \"immutable\"\nimport {\n  talentsBySpec,\n  talentToSpec,\n  talentsBySpecArray,\n  talentsById\n} from \"../data/talents\"\nimport { classById } from \"../data/classes\"\nimport spells from \"../data/spells.json\"\n\nexport const MAX_POINTS = 51\nexport const MAX_ROWS = 7\n\nexport const SORT_TALENTS = (a, b) => {\n  if (a.row === b.row) {\n    return a.col - b.col\n  }\n  return a.row - b.row\n}\n\nexport const SORT_TALENTS_DESC = (a, b) => {\n  if (a.row === b.row) {\n    return b.col - a.col\n  }\n  return b.row - a.row\n}\n\nexport const SORT_TALENTS_BY_SPEC = (a, b) => {\n  const aSpec = talentToSpec[a.id]\n  const bSpec = talentToSpec[b.id]\n  if (aSpec === bSpec) {\n    return SORT_TALENTS(a, b)\n  }\n  return aSpec - bSpec\n}\n\n/**\n * Returns the overall points spent in the tree.\n */\nexport function getPointsInSpec(specId, known) {\n  // TODO: Hard to test this method when referencing talents from a file. Improve this.\n  return Object.values(talentsBySpec[specId]).reduce((prev, current) => {\n    return prev + known.get(current.id, 0)\n  }, 0)\n}\n\nexport function calcAvailablePoints(known) {\n  return Math.max(\n    0,\n    MAX_POINTS - known.reduce((prev, current) => prev + current, 0)\n  )\n}\n\n/**\n * Returns whether a talent's other talent requirements are met.\n */\nexport function calcMeetsRequirements(talent, known) {\n  if (talent.requires.length === 0) {\n    return true\n  }\n  return talent.requires.reduce((prev, req) => {\n    if (!prev) return false\n    return known.get(req.id, 0) >= req.qty\n  }, true)\n}\n\nexport function getNameForTalent(talentId) {\n  const spell = spells[talentsById[talentId].ranks[0]]\n  if (spell) return spell.name\n  return \"Unknown\"\n}\n\nexport function getUnmetRequirements(talent, known, pointsInSpec, specName) {\n  const missing = []\n  const dependency = talent.requires[0]\n  if (dependency && known.get(dependency.id, 0) < dependency.qty) {\n    missing.push(\n      `Requires ${dependency.qty} point${\n        dependency.qty !== 1 ? \"s\" : \"\"\n      } in ${getNameForTalent(dependency.id)}`\n    )\n  }\n\n  if (talent.row * 5 > pointsInSpec) {\n    missing.push(`Requires ${talent.row * 5} points in ${specName}`)\n  }\n\n  // Hackfix: Returning an Array will cause the prop to change everytime, causing re-renders on all\n  // of the components. Returning a string makes the shallow compare easier and prevents re-renders.\n  // Could add Memoization to this function, but not sure of another \"better\" more \"React\" way..\n  return missing.join(\"_\")\n}\n\nexport const canLearnTalent = (known, talent) => {\n  // Reached the max rank?\n  if (known.get(talent.id, 0) >= talent.ranks.length) {\n    return false\n  }\n\n  // Spend a maximum of 51 points\n  if (calcAvailablePoints(known) === 0) {\n    return false\n  }\n\n  // Support for specific Talent dependency requirement.\n  if (talent.requires.length > 0 && !calcMeetsRequirements(talent, known)) {\n    return false\n  }\n\n  // Check we have the required amount of points spent in the tree for this talent\n  const requiredPoints = talent.row * 5\n  const pointsInSpec = getPointsInSpec(talentToSpec[talent.id], known)\n  if (requiredPoints > pointsInSpec) {\n    return false\n  }\n\n  return true\n}\n\nexport const getCumulativePointsPerRow = (known, specId) => {\n  return known.reduce((reduction, points, talentId) => {\n    const t = talentsBySpec[specId][talentId]\n    if (t && points > 0) {\n      for (let row = t.row; row < MAX_ROWS; row++) {\n        reduction[row] = (reduction[row] || 0) + points\n      }\n    }\n    return reduction\n  }, [])\n}\n\nexport const canUnlearnTalent = (known, talent) => {\n  const currentPoints = known.get(talent.id, 0)\n  const specId = talentToSpec[talent.id]\n\n  // No points to reduce for this talent\n  if (currentPoints === 0) {\n    console.warn(\"no points to reduce\")\n    return false\n  }\n\n  // Prevent if another talent depends on this\n  const isDependency = known.some((points, talentId) => {\n    const t = talentsBySpec[specId][talentId]\n    return t && points > 0 && t.requires.some(req => req.id === talent.id)\n  })\n  if (isDependency) {\n    console.warn(\"is dependency\")\n    return false\n  }\n\n  // Walk through every talent and ensure no requirements are breached\n  let cumulativePointsPerRow = getCumulativePointsPerRow(known, specId)\n  for (let r = talent.row; r < cumulativePointsPerRow.length; r++) {\n    // Calculate what the points would look like when this one is removed\n    cumulativePointsPerRow[r] = cumulativePointsPerRow[r] - 1\n  }\n  const wouldBreach = known.some((points, talentId) => {\n    const t = talentsBySpec[specId][talentId]\n    return (\n      t &&\n      points > 0 &&\n      t.row > 0 &&\n      cumulativePointsPerRow[t.row - 1] < t.row * 5\n    )\n  })\n  if (wouldBreach) {\n    console.warn(\"point requirements would be breached\")\n    return false\n  }\n\n  return true\n}\n\n/**\n * Adds a single talent point to the Map, if possible.\n */\nexport const addTalentPoint = (known, talent) => {\n  const currentPoints = known.get(talent.id, 0)\n\n  if (!canLearnTalent(known, talent)) {\n    return known\n  }\n\n  return known.set(talent.id, currentPoints + 1)\n}\n\n/**\n * Removes a single talent point from the Map, if possible.\n */\nexport const removeTalentPoint = (known, talent) => {\n  const currentPoints = known.get(talent.id, 0)\n\n  if (!canUnlearnTalent(known, talent)) {\n    return known\n  }\n\n  return currentPoints === 1\n    ? known.remove(talent.id)\n    : known.set(talent.id, currentPoints - 1)\n}\n\n/**\n * Either adds or removes a talent point based on the modifier.\n */\nexport const modifyTalentPoint = (known, talent, modifier) => {\n  if (modifier === 1) {\n    return addTalentPoint(known, talent)\n  } else {\n    return removeTalentPoint(known, talent)\n  }\n}\n\n/**\n * Encodes a Map of known talents into a URL-friendly string.\n */\nexport function encodeKnownTalents(known, classId) {\n  let string = \"\"\n  const { specs } = classById[classId]\n  for (let i = 0; i < specs.length; i++) {\n    const specId = specs[i]\n    const talents = talentsBySpecArray[specId].sort(SORT_TALENTS)\n    string += i > 0 ? \"-\" : \"\"\n    string += removeTrailingCharacters(\n      talents.map(talent => known.get(talent.id, 0)).join(\"\"),\n      \"0\"\n    )\n  }\n  return removeTrailingCharacters(string, \"-\")\n}\n\n/**\n * Decodes a string of points into a Map of talents.\n */\nexport function decodeKnownTalents(pointString, classId) {\n  const { specs } = classById[classId]\n  let known = Map()\n\n  // TODO: Make sure we validate the point string\n  const parts = pointString.split(\"-\")\n  for (let i = 0; i < parts.length; i++) {\n    const specId = specs[i]\n    const specPointStr = parts[i]\n    const talents = talentsBySpecArray[specId].sort(SORT_TALENTS)\n\n    for (let y = 0; y < specPointStr.length; y++) {\n      const talent = talents[y]\n      const points = parseInt(specPointStr[y], 10)\n\n      // Validation: break out loop if there's more points in the string than this talent can have\n      if (points > talent.ranks.length) {\n        break\n      }\n\n      // Step through each point and see that we can assign it\n      for (let p = 0; p < points; p++) {\n        if (canLearnTalent(known, talent)) {\n          known = known.set(talent.id, p + 1)\n        } else {\n          break\n        }\n      }\n    }\n  }\n\n  return known\n}\n\n/**\n * Removes repeated characters from the end of a string.\n */\nfunction removeTrailingCharacters(str, char) {\n  while (str[str.length - 1] === char) {\n    str = str.slice(0, -1)\n  }\n  return str\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}